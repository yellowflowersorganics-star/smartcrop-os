[
  {
    "id": "cropwise_gateway_flow",
    "type": "tab",
    "label": "CropWise Gateway - Unit Management",
    "disabled": false,
    "info": "Main flow for CropWise Raspberry Pi Gateway\n\nFunctions:\n- Aggregate telemetry from all ESP32 zones\n- Forward to cloud\n- Local recipe execution\n- Offline buffering\n- Gateway heartbeat"
  },
  {
    "id": "esp32_telemetry_in",
    "type": "mqtt in",
    "z": "cropwise_gateway_flow",
    "name": "ESP32 Telemetry In",
    "topic": "+/+/telemetry",
    "qos": "1",
    "datatype": "json",
    "broker": "local_mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 140,
    "y": 100,
    "wires": [["telemetry_aggregator"]]
  },
  {
    "id": "telemetry_aggregator",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Aggregate Telemetry",
    "func": "// Parse topic: unit1/zone_a/telemetry\nconst parts = msg.topic.split('/');\nconst unitId = parts[0];\nconst zoneId = parts[1];\n\n// Get payload\nconst telemetry = msg.payload;\n\n// Store in context for aggregation\nconst timestamp = Date.now();\nconst key = `${unitId}_${zoneId}`;\n\n// Get or initialize aggregation buffer\nlet buffer = flow.get('telemetry_buffer') || {};\n\n// Add telemetry with metadata\nbuffer[key] = {\n    unitId: unitId,\n    zoneId: zoneId,\n    temperature: telemetry.temperature,\n    humidity: telemetry.humidity,\n    co2: telemetry.co2,\n    light: telemetry.light || null,\n    timestamp: telemetry.timestamp || new Date().toISOString(),\n    receivedAt: new Date().toISOString()\n};\n\nflow.set('telemetry_buffer', buffer);\n\n// Update node status\nnode.status({\n    fill: 'green',\n    shape: 'dot',\n    text: `${Object.keys(buffer).length} zones buffered`\n});\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 100,
    "wires": [["local_storage"]]
  },
  {
    "id": "local_storage",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Store Locally (SQLite)",
    "func": "// Store telemetry locally for offline buffering\n// In production, this would write to SQLite\n\nconst db = global.get('localdb') || [];\n\n// Add to local database\ndb.push({\n    topic: msg.topic,\n    payload: msg.payload,\n    timestamp: new Date().toISOString()\n});\n\n// Keep only last 1000 records\nif (db.length > 1000) {\n    db.shift();\n}\n\nglobal.set('localdb', db);\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 630,
    "y": 100,
    "wires": [[]]
  },
  {
    "id": "publish_aggregated_timer",
    "type": "inject",
    "z": "cropwise_gateway_flow",
    "name": "Every 60 seconds",
    "props": [],
    "repeat": "60",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "",
    "x": 160,
    "y": 200,
    "wires": [["aggregate_and_publish"]]
  },
  {
    "id": "aggregate_and_publish",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Aggregate & Publish to Cloud",
    "func": "// Get configuration\nconst orgId = env.get('ORGANIZATION_ID') || 'org_abc123';\nconst unitId = env.get('UNIT_ID') || 'unit_001';\n\n// Get buffered telemetry\nconst buffer = flow.get('telemetry_buffer') || {};\n\nif (Object.keys(buffer).length === 0) {\n    node.warn('No telemetry to publish');\n    return null;\n}\n\n// Convert buffer to array of zones\nconst zones = Object.values(buffer);\n\n// Create aggregated payload\nconst payload = {\n    organization_id: orgId,\n    unit_id: unitId,\n    gateway_id: env.get('GATEWAY_ID') || 'unknown',\n    zones: zones,\n    zone_count: zones.length,\n    timestamp: new Date().toISOString()\n};\n\n// Clear buffer after aggregation\nflow.set('telemetry_buffer', {});\n\n// Set topic for cloud MQTT\nmsg.topic = `yfcloud/${orgId}/${unitId}/telemetry_aggregated`;\nmsg.payload = payload;\n\nnode.status({\n    fill: 'blue',\n    shape: 'dot',\n    text: `Published ${zones.length} zones`\n});\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 200,
    "wires": [["cloud_mqtt_out", "api_forward"]]
  },
  {
    "id": "cloud_mqtt_out",
    "type": "mqtt out",
    "z": "cropwise_gateway_flow",
    "name": "Cloud MQTT Out",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "cloud_mqtt_broker",
    "x": 710,
    "y": 200,
    "wires": []
  },
  {
    "id": "api_forward",
    "type": "http request",
    "z": "cropwise_gateway_flow",
    "name": "Forward to Backend API",
    "method": "POST",
    "ret": "txt",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [
      {
        "keyType": "other",
        "keyValue": "Authorization",
        "valueType": "str",
        "valueValue": "Bearer {{API_TOKEN}}"
      },
      {
        "keyType": "Content-Type",
        "keyValue": "",
        "valueType": "other",
        "valueValue": "application/json"
      }
    ],
    "x": 730,
    "y": 260,
    "wires": [[]]
  },
  {
    "id": "gateway_heartbeat_timer",
    "type": "inject",
    "z": "cropwise_gateway_flow",
    "name": "Every 60 seconds",
    "props": [],
    "repeat": "60",
    "crontab": "",
    "once": true,
    "onceDelay": "10",
    "topic": "",
    "x": 160,
    "y": 340,
    "wires": [["generate_heartbeat"]]
  },
  {
    "id": "generate_heartbeat",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Generate Gateway Heartbeat",
    "func": "const os = require('os');\n\n// Get configuration\nconst orgId = env.get('ORGANIZATION_ID') || 'org_abc123';\nconst unitId = env.get('UNIT_ID') || 'unit_001';\nconst gatewayId = env.get('GATEWAY_ID') || os.networkInterfaces().eth0?.[0]?.mac || 'unknown';\n\n// Get ESP32 zone statuses from context\nconst buffer = flow.get('telemetry_buffer') || {};\nconst zoneStatuses = Object.keys(buffer).map(key => {\n    const zone = buffer[key];\n    return {\n        zone_id: zone.zoneId,\n        esp32_id: zone.deviceId || 'unknown',\n        status: 'online',\n        last_seen: zone.receivedAt\n    };\n});\n\n// System info\nconst payload = {\n    gatewayId: gatewayId,\n    ipAddress: getLocalIP(),\n    version: env.get('GATEWAY_VERSION') || '1.0.0',\n    zoneStatuses: zoneStatuses,\n    systemInfo: {\n        cpuTemp: getCPUTemp(),\n        memoryUsage: (os.totalmem() - os.freemem()) / os.totalmem() * 100,\n        diskUsage: 0, // Would need disk check\n        uptime: os.uptime()\n    }\n};\n\n// Helper functions\nfunction getLocalIP() {\n    const nets = os.networkInterfaces();\n    for (const name of Object.keys(nets)) {\n        for (const net of nets[name]) {\n            if (net.family === 'IPv4' && !net.internal) {\n                return net.address;\n            }\n        }\n    }\n    return '127.0.0.1';\n}\n\nfunction getCPUTemp() {\n    // On Raspberry Pi, read from /sys/class/thermal/thermal_zone0/temp\n    // For demo, return simulated value\n    return 45.0 + Math.random() * 10;\n}\n\n// Set topic and payload\nmsg.topic = `yfcloud/${orgId}/${unitId}/gateway_status`;\nmsg.payload = payload;\n\nnode.status({\n    fill: 'green',\n    shape: 'ring',\n    text: `Online - ${zoneStatuses.length} zones`\n});\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 340,
    "wires": [["cloud_mqtt_out", "api_heartbeat"]]
  },
  {
    "id": "api_heartbeat",
    "type": "http request",
    "z": "cropwise_gateway_flow",
    "name": "POST Heartbeat to API",
    "method": "POST",
    "ret": "txt",
    "paytoqs": "ignore",
    "url": "{{API_URL}}/api/units/{{UNIT_ID}}/gateway-heartbeat",
    "tls": "",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "bearer",
    "senderr": false,
    "headers": [],
    "x": 720,
    "y": 340,
    "wires": [[]]
  },
  {
    "id": "cloud_setpoints_in",
    "type": "mqtt in",
    "z": "cropwise_gateway_flow",
    "name": "Cloud Setpoints In",
    "topic": "yfcloud/+/+/setpoints_bulk",
    "qos": "1",
    "datatype": "json",
    "broker": "cloud_mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 150,
    "y": 460,
    "wires": [["distribute_setpoints"]]
  },
  {
    "id": "distribute_setpoints",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Distribute to ESP32 Zones",
    "func": "// Payload contains setpoints for multiple zones\nconst setpoints = msg.payload;\n\nif (!setpoints.zones || !Array.isArray(setpoints.zones)) {\n    node.warn('Invalid setpoints format');\n    return null;\n}\n\n// Create messages for each zone\nconst messages = [];\n\nfor (const zone of setpoints.zones) {\n    const zoneId = zone.zone_id;\n    const unitId = zone.unit_id || env.get('UNIT_ID') || 'unit1';\n    \n    messages.push({\n        topic: `${unitId}/${zoneId}/setpoints`,\n        payload: {\n            temperature: zone.temperature,\n            humidity: zone.humidity,\n            co2: zone.co2,\n            light: zone.light,\n            timestamp: new Date().toISOString()\n        },\n        qos: 1,\n        retain: true\n    });\n}\n\nnode.status({\n    fill: 'blue',\n    shape: 'dot',\n    text: `Distributed to ${messages.length} zones`\n});\n\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 460,
    "wires": [["local_mqtt_out"]]
  },
  {
    "id": "local_mqtt_out",
    "type": "mqtt out",
    "z": "cropwise_gateway_flow",
    "name": "Local MQTT Out (to ESP32s)",
    "topic": "",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "local_mqtt_broker",
    "x": 730,
    "y": 460,
    "wires": []
  },
  {
    "id": "cloud_command_in",
    "type": "mqtt in",
    "z": "cropwise_gateway_flow",
    "name": "Cloud Commands In",
    "topic": "yfcloud/+/+/command",
    "qos": "1",
    "datatype": "json",
    "broker": "cloud_mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 150,
    "y": 560,
    "wires": [["handle_command"]]
  },
  {
    "id": "handle_command",
    "type": "function",
    "z": "cropwise_gateway_flow",
    "name": "Handle Command",
    "func": "// Parse command from cloud\nconst command = msg.payload;\n\nswitch (command.action) {\n    case 'restart_gateway':\n        node.warn('Gateway restart requested');\n        // In production: exec('sudo reboot')\n        break;\n        \n    case 'restart_zone':\n        // Forward restart command to specific ESP32\n        const zoneId = command.zone_id;\n        const unitId = env.get('UNIT_ID') || 'unit1';\n        return {\n            topic: `${unitId}/${zoneId}/command`,\n            payload: { action: 'restart' },\n            qos: 1\n        };\n        \n    case 'update_firmware':\n        node.warn('Firmware update requested');\n        // Handle OTA update\n        break;\n        \n    case 'get_logs':\n        // Return logs\n        const logs = global.get('gateway_logs') || [];\n        return {\n            topic: `yfcloud/${env.get('ORGANIZATION_ID')}/${env.get('UNIT_ID')}/logs`,\n            payload: { logs: logs.slice(-100) },\n            qos: 1\n        };\n        \n    default:\n        node.warn('Unknown command: ' + command.action);\n}\n\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 560,
    "wires": [["local_mqtt_out", "cloud_mqtt_out"]]
  },
  {
    "id": "local_mqtt_broker",
    "type": "mqtt-broker",
    "name": "Local Mosquitto (ESP32s)",
    "broker": "localhost",
    "port": "1883",
    "clientid": "",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "birthMsg": {},
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "closeMsg": {},
    "willTopic": "",
    "willQos": "0",
    "willPayload": "",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  },
  {
    "id": "cloud_mqtt_broker",
    "type": "mqtt-broker",
    "name": "CropWise Cloud MQTT",
    "broker": "mqtt.cropwise.cloud",
    "port": "8883",
    "tls": "tls_config",
    "clientid": "",
    "autoConnect": true,
    "usetls": true,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "credentials": {},
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "birthMsg": {},
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "closeMsg": {},
    "willTopic": "",
    "willQos": "0",
    "willPayload": "",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  },
  {
    "id": "tls_config",
    "type": "tls-config",
    "name": "Cloud TLS",
    "cert": "",
    "key": "",
    "ca": "",
    "certname": "gateway.crt",
    "keyname": "gateway.key",
    "caname": "ca.crt",
    "servername": "mqtt.cropwise.cloud",
    "verifyservercert": true,
    "alpnprotocol": ""
  }
]

